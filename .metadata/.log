!SESSION 2023-02-20 16:14:32.916 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-20 16:14:53.190
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-20 16:14:53.190
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-20 16:14:53.190
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-20 16:14:55.740
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-20 16:15:06.314
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 16:28:39.607
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Scanner;//创建矩阵用到
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;

/**
 * @author 20680
 *
 */



//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		System.out.println("数据向量格式：" + dataVector);
		System.out.println("数据向量大小：" + dataVector.size());
		System.out.println("所有文档字符总数Lcount:" + Lcount);
		double Lave = Lcount / fileAmount;
		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
			if(file.exists()) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
		System.out.println("密钥向量S：" + S);
		
		
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
//		double [][] M2;
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		//输出矩阵信息
//		M1.show();
//		M2.show();
		
		
		//用密钥S对向量D进行分裂
		Vector<Double> D1 = new Vector<>();
		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

				
		SimpleMatrix matrixD = new SimpleMatrix(4, 4);
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == j) {
                    matrixD.set(i, j, i + 1);
                } else {
                    matrixD.set(i, j, 0);
                }
            }
        }
        System.out.println("矩阵D:\n"+matrixD);
 
        SimpleMatrix D_invert = matrixD.invert();
        System.out.println("矩阵D的逆阵:\n"+D_invert);
 
        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
————————————————
版权声明：本文为CSDN博主「cry-newbie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_45965703/article/details/120713490
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime-stime));
			
	}
	
	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 * @return 
	 */
	private static Collection<Vector> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
//		Vector m1Td1 = ;
//		Vector m2Td2 = ;
		ColD.add(d1);
		ColD.add(d2);
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(200)-100);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 16:28:39.608
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 16:28:39.608
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 16:28:39.694
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Scanner;//创建矩阵用到
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;

/**
 * @author 20680
 *
 */



//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		System.out.println("数据向量格式：" + dataVector);
		System.out.println("数据向量大小：" + dataVector.size());
		System.out.println("所有文档字符总数Lcount:" + Lcount);
		double Lave = Lcount / fileAmount;
		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
			if(file.exists()) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
		System.out.println("密钥向量S：" + S);
		
		
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
//		double [][] M2;
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		//输出矩阵信息
//		M1.show();
//		M2.show();
		
		
		//用密钥S对向量D进行分裂
		Vector<Double> D1 = new Vector<>();
		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

				
		SimpleMatrix matrixD = new SimpleMatrix(4, 4);
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == j) {
                    matrixD.set(i, j, i + 1);
                } else {
                    matrixD.set(i, j, 0);
                }
            }
        }
        System.out.println("矩阵D:\n"+matrixD);
 
        SimpleMatrix D_invert = matrixD.invert();
        System.out.println("矩阵D的逆阵:\n"+D_invert);
 
        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
————————————————
版权声明：本文为CSDN博主「cry-newbie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_45965703/article/details/120713490
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime-stime));
			
	}
	
	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 * @return 
	 */
	private static Collection<Vector> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
//		Vector m1Td1 = ;
//		Vector m2Td2 = ;
		ColD.add(d1);
		ColD.add(d2);
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(200)-100);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 16:28:39.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 16:28:39.697
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 16:28:45.051
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Scanner;//创建矩阵用到
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;

/**
 * @author 20680
 *
 */



//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		System.out.println("数据向量格式：" + dataVector);
		System.out.println("数据向量大小：" + dataVector.size());
		System.out.println("所有文档字符总数Lcount:" + Lcount);
		double Lave = Lcount / fileAmount;
		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
			if(file.exists()) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
		System.out.println("密钥向量S：" + S);
		
		
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
//		double [][] M2;
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		//输出矩阵信息
//		M1.show();
//		M2.show();
		
		
		//用密钥S对向量D进行分裂
		Vector<Double> D1 = new Vector<>();
		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

				
		SimpleMatrix matrixD = new SimpleMatrix(4, 4);
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == j) {
                    matrixD.set(i, j, i + 1);
                } else {
                    matrixD.set(i, j, 0);
                }
            }
        }
        System.out.println("矩阵D:\n"+matrixD);
 
        SimpleMatrix D_invert = matrixD.invert();
        System.out.println("矩阵D的逆阵:\n"+D_invert);
 
        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
————————————————
版权声明：本文为CSDN博主「cry-newbie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_45965703/article/details/120713490
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime-stime));
			
	}
	
	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 * @return 
	 */
	private static Collection<Vector> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
//		Vector m1Td1 = ;
//		Vector m2Td2 = ;
		ColD.add(d1);
		ColD.add(d2);
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(200)-100);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 16:28:45.053
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 16:28:45.053
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 16:28:46.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Scanner;//创建矩阵用到
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;

/**
 * @author 20680
 *
 */



//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		System.out.println("数据向量格式：" + dataVector);
		System.out.println("数据向量大小：" + dataVector.size());
		System.out.println("所有文档字符总数Lcount:" + Lcount);
		double Lave = Lcount / fileAmount;
		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
			if(file.exists()) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
		System.out.println("密钥向量S：" + S);
		
		
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
//		double [][] M2;
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		//输出矩阵信息
//		M1.show();
//		M2.show();
		
		
		//用密钥S对向量D进行分裂
		Vector<Double> D1 = new Vector<>();
		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

				
		SimpleMatrix matrixD = new SimpleMatrix(4, 4);
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == j) {
                    matrixD.set(i, j, i + 1);
                } else {
                    matrixD.set(i, j, 0);
                }
            }
        }
        System.out.println("矩阵D:\n"+matrixD);
 
        SimpleMatrix D_invert = matrixD.invert();
        System.out.println("矩阵D的逆阵:\n"+D_invert);
 
        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
————————————————
版权声明：本文为CSDN博主「cry-newbie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_45965703/article/details/120713490
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime-stime));
			
	}
	
	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 * @return 
	 */
	private static Collection<Vector> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
//		Vector m1Td1 = ;
//		Vector m2Td2 = ;
		ColD.add(d1);
		ColD.add(d2);
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(200)-100);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1542)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4867)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4745)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 16:28:46.346
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1542)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4867)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4745)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 16:28:46.347
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1542)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4867)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4745)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 16:28:46.422
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Scanner;//创建矩阵用到
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;

/**
 * @author 20680
 *
 */



//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		System.out.println("数据向量格式：" + dataVector);
		System.out.println("数据向量大小：" + dataVector.size());
		System.out.println("所有文档字符总数Lcount:" + Lcount);
		double Lave = Lcount / fileAmount;
		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
			if(file.exists()) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
		System.out.println("密钥向量S：" + S);
		
		
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
//		double [][] M2;
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		//输出矩阵信息
//		M1.show();
//		M2.show();
		
		
		//用密钥S对向量D进行分裂
		Vector<Double> D1 = new Vector<>();
		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

				
		SimpleMatrix matrixD = new SimpleMatrix(4, 4);
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                if (i == j) {
                    matrixD.set(i, j, i + 1);
                } else {
                    matrixD.set(i, j, 0);
                }
            }
        }
        System.out.println("矩阵D:\n"+matrixD);
 
        SimpleMatrix D_invert = matrixD.invert();
        System.out.println("矩阵D的逆阵:\n"+D_invert);
 
        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
————————————————
版权声明：本文为CSDN博主「cry-newbie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_45965703/article/details/120713490
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime-stime));
			
	}
	
	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 * @return 
	 */
	private static Collection<Vector> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
//		Vector m1Td1 = ;
//		Vector m2Td2 = ;
		ColD.add(d1);
		ColD.add(d2);
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(200)-100);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 16:28:46.423
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 16:28:46.423
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 22:43:24.176
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ejml.simple.SimpleMatrix;
import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;
/**
 * @author 20680
 *
 */


//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime1 = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		double Lave = Lcount / fileAmount;
//		System.out.println("数据向量格式：" + dataVector);
//		System.out.println("数据向量大小：" + dataVector.size());
//		System.out.println("所有文档字符总数Lcount:" + Lcount);
//		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
//			if(file.exists()) {
			if(i<9) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
//		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
//		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
//		System.out.println("密钥向量S：" + S);
		
		
		long etime1 = System.currentTimeMillis();
//		System.out.printf("执行时长：%d毫秒", (etime1-stime1));
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		long stime2 = System.currentTimeMillis();
		//输出矩阵信息
//		M1.show();
//		M2.show();
//		BaseMatrix m1_1 =  M1.invert();//求逆矩阵
//		m1_1.show();
		
		//
		EncryptNode Encry_headNode =new EncryptNode();
		EncrytBTree(S,M1,M2, HeadNode,Encry_headNode);
		
//		double [][]matrix = {{1.0,2.0,3.0},{3.0,4.0,5.0},{1.0,1.0,2.0}};
//		BaseMatrix m1 = new BaseMatrix(matrix);
//		m1.show();
//		Vector<Double> s = new Vector<>();
//		s.add(0, 1.0);
//		s.add(1, 2.0);
//		s.add(2, 1.0);
//		System.out.println("s:"+s);
//		Vector<Double> s2 = m1.mult(s);
//		System.out.println("S2:"+s2);
		
		
		//用密钥S对向量D进行分裂
//		Vector<Double> D1 = new Vector<>();
//		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

//				
//		SimpleMatrix matrixD = new SimpleMatrix(2, 2);
//        for (int i = 0; i < 2; i++) {
//            for (int j = 0; j < 2; j++) {
//                if (i == j) {
//                    matrixD.set(i, j, i + 1);
//                } else {
//                    matrixD.set(i, j, i + 2);
//                }
//            }
//        }
//        System.out.println("矩阵D:\n"+matrixD);
//        
//// 
//        SimpleMatrix D_invert = matrixD.invert();
//        System.out.println("矩阵D的逆阵:\n"+D_invert);
// 
//        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
//        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime2 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime2-stime2)(etime2-stime2));
			
	}
	
	
	/**
	 * 根据密钥S,M1,M2分裂树中所有D向量，构建加密树，返回加密树的头节点
	 * @return 
	 * 
	 */
	private static void EncrytBTree(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, LeafNode Node,
			EncryptNode encry_Node) {
		Collection<Vector<Double>> Iu = new Vector<>() ;// 计算Iu={m1Td1，m2Td2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 | Node.D.get(i)==0) {  //S[i]=0 
				d1.add(Node.D.get(i));
				d2.add(Node.D.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
//				System.out.println("Node.D.get(i):"+Node.D.get(i));
				double a = Math.abs(rand.nextDouble(Node.D.get(i)));
				double b = Node.D.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		Iu.add(m1T.mult(d1));
		Iu.add(m2T.mult(d2));
		
		// 创建加密树节点
		EncryptNode e_lnode = new EncryptNode();
		EncryptNode e_rnode = new EncryptNode();
		
		// 为加密树节点添加数据
		encry_Node.setIu(Iu);
		if(Node.Lchild==null&Node.Rchild==null) {// 左右子节点为空，则为叶子节点
			encry_Node.setFid(Node.Fid);// 为叶子节点加入Fid
		}
		encry_Node.setLchild(e_lnode);
		encry_Node.setRchild(e_rnode);
//		System.out.println("encry_Node.Iu:"+encry_Node.getIu());
		
		//递归构建加密树
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Lchild,e_lnode);
		}
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Rchild,e_rnode);
		}
						
	}

	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 */
	private static Collection<Vector<Double>> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector<Double>> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		ColD.add(m1T.mult(d1));
		ColD.add(m2T.mult(d2));
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(2000)-1000);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 22:43:24.183
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 22:43:24.183
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 22:43:24.337
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ejml.simple.SimpleMatrix;
import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;
/**
 * @author 20680
 *
 */


//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		long stime1 = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(10)\\";// 我要遍历指定地址下的文件
		int fileAmount = 10;// 文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
				} 
			}
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
			
		}
		double Lave = Lcount / fileAmount;
//		System.out.println("数据向量格式：" + dataVector);
//		System.out.println("数据向量大小：" + dataVector.size());
//		System.out.println("所有文档字符总数Lcount:" + Lcount);
//		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		// 创建足够多的叶子节点用于构造二叉树，构建64个叶子节点
		int count = 64;
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建64个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
//			if(file.exists()) {
			if(i<9) {
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					double tfw = tfws.get(word);
					double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//					System.out.println("数据Di swf:" + swf);
					leafnode.dataVector.put(word, swf);
				}
				
//				System.out.println("数据向量格式：" + dataVector);
//				System.out.println("数据向量格式大小：" + dataVector.size());
//				System.out.println("leafnode.dataVector：" + leafnode.dataVector);
//				System.out.println("leafnode.dataVector.size：" + leafnode.dataVector.size());
//				System.out.println("");
				
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				leafnode.dataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(leafnode.dataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
//		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
		CreatBTree(HeadNode,LeafNodes);
//		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
//		System.out.println("密钥向量S：" + S);
		
		
		long etime1 = System.currentTimeMillis();
//		System.out.printf("执行时长：%d毫秒", (etime1-stime1));
		//自定义可逆矩阵M1，M2
//		double [][] M1;//用二维数组存储矩阵，
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		long stime2 = System.currentTimeMillis();
		//输出矩阵信息
//		M1.show();
//		M2.show();
//		BaseMatrix m1_1 =  M1.invert();//求逆矩阵
//		m1_1.show();
		
		//
		EncryptNode Encry_headNode =new EncryptNode();
		EncrytBTree(S,M1,M2, HeadNode,Encry_headNode);
		
//		double [][]matrix = {{1.0,2.0,3.0},{3.0,4.0,5.0},{1.0,1.0,2.0}};
//		BaseMatrix m1 = new BaseMatrix(matrix);
//		m1.show();
//		Vector<Double> s = new Vector<>();
//		s.add(0, 1.0);
//		s.add(1, 2.0);
//		s.add(2, 1.0);
//		System.out.println("s:"+s);
//		Vector<Double> s2 = m1.mult(s);
//		System.out.println("S2:"+s2);
		
		
		//用密钥S对向量D进行分裂
//		Vector<Double> D1 = new Vector<>();
//		Vector<Double> D2 = new Vector<>();
//		 SplitD1(S,M1,M2,HeadNode.D);
		
//		System.out.println("D1 and D2"+ SplitD1(S,M1,M2,HeadNode.D));//输出向量集合{D1，D2}

//				
//		SimpleMatrix matrixD = new SimpleMatrix(2, 2);
//        for (int i = 0; i < 2; i++) {
//            for (int j = 0; j < 2; j++) {
//                if (i == j) {
//                    matrixD.set(i, j, i + 1);
//                } else {
//                    matrixD.set(i, j, i + 2);
//                }
//            }
//        }
//        System.out.println("矩阵D:\n"+matrixD);
//        
//// 
//        SimpleMatrix D_invert = matrixD.invert();
//        System.out.println("矩阵D的逆阵:\n"+D_invert);
// 
//        SimpleMatrix D_pseudoInverse = matrixD.pseudoInverse();
//        System.out.println("矩阵D的广义逆阵:\n"+D_pseudoInverse);
		
		// 遍历 .txt 文件，计算节点S(w,f)
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime2 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒", (etime2-stime2)(etime2-stime2));
			
	}
	
	
	/**
	 * 根据密钥S,M1,M2分裂树中所有D向量，构建加密树，返回加密树的头节点
	 * @return 
	 * 
	 */
	private static void EncrytBTree(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, LeafNode Node,
			EncryptNode encry_Node) {
		Collection<Vector<Double>> Iu = new Vector<>() ;// 计算Iu={m1Td1，m2Td2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 | Node.D.get(i)==0) {  //S[i]=0 
				d1.add(Node.D.get(i));
				d2.add(Node.D.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
//				System.out.println("Node.D.get(i):"+Node.D.get(i));
				double a = Math.abs(rand.nextDouble(Node.D.get(i)));
				double b = Node.D.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		Iu.add(m1T.mult(d1));
		Iu.add(m2T.mult(d2));
		
		// 创建加密树节点
		EncryptNode e_lnode = new EncryptNode();
		EncryptNode e_rnode = new EncryptNode();
		
		// 为加密树节点添加数据
		encry_Node.setIu(Iu);
		if(Node.Lchild==null&Node.Rchild==null) {// 左右子节点为空，则为叶子节点
			encry_Node.setFid(Node.Fid);// 为叶子节点加入Fid
		}
		encry_Node.setLchild(e_lnode);
		encry_Node.setRchild(e_rnode);
//		System.out.println("encry_Node.Iu:"+encry_Node.getIu());
		
		//递归构建加密树
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Lchild,e_lnode);
		}
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Rchild,e_rnode);
		}
						
	}

	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量 
	 * @return 
	 * 
	 */
	private static Collection<Vector<Double>> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector<Double>> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		ColD.add(m1T.mult(d1));
		ColD.add(m2T.mult(d2));
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(2000)-1000);
					m[i][j] = r;
				}
			}
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
		}
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< dataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接左节点
					headNode.Rchild=rNode;// 连接右节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 22:43:24.337
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 22:43:24.338
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2477)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-02-21 15:33:33.135 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-02-21 15:33:43.638
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-02-21 15:33:46.641
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 15:33:46.641
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 15:33:46.641
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.core.resources 4 1 2023-02-21 15:33:48.335
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2023-02-21 15:33:48.340
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-21 15:33:48.947
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-21 15:33:58.406
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-21 22:45:18.494 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-21 22:45:23.304
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 22:45:23.304
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 22:45:23.304
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-21 22:45:26.074
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-21 22:45:34.018
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-22 09:01:18.253 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-22 09:01:24.774
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 09:01:24.774
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 09:01:24.774
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-22 09:01:35.349
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-22 09:02:15.103
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-23 14:24:52.226 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-23 14:24:57.145
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 14:24:57.145
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 14:24:57.145
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-23 14:25:00.071
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-23 14:25:08.042
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-23 15:52:53.622 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-23 15:52:57.646
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 15:52:57.646
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 15:52:57.646
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-23 15:53:00.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-23 15:53:08.125
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY org.eclipse.jdt.core 4 4 2023-02-24 22:20:13.998
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ejml.simple.SimpleMatrix;
import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;
/**
 * @author 20680
 *
 */


//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable DataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	static long stime1;
	static int nodecount;
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		stime1 = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFC9056\\";// 我要遍历指定地址下的文件
		int fileAmount = 4000;// 构建关键词使用的文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		Map<String, Integer> Word_Count_Dictionary = new TreeMap<String, Integer>();// 构建字典（包含word词的文件个数）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式,获取关键字集及映射的数据向量（向量大小）
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
					Word_Count_Dictionary.put(word, 1);
				} else {
					Word_Count_Dictionary.put(word, Word_Count_Dictionary.get(word) + 1);
				}
			}
			
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
		}
//		System.out.println("Word_Count_Dictionary：" + Word_Count_Dictionary);
		

		double Lave = Lcount / fileAmount;
//		System.out.println("数据向量格式：" + dataVector);
//		System.out.println("数据向量大小：" + dataVector.size());
//		System.out.println("所有文档字符总数Lcount:" + Lcount);
//		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		System.out.println("原数据向量大小：" + dataVector.size());
		// 数据向量去低频词
		int Low_frequency_word_counter = 0;
		for(String word : Word_Count_Dictionary.keySet() ) {
//			double lf = fileAmount*0.1;
			double lf = 365;
			// 记录低频词的数量，并将其从数据向量中移除
			if (Word_Count_Dictionary.get(word) <= lf) {
				Low_frequency_word_counter += 1;
				dataVector.remove(word);
			}
		}
		System.out.println("低频单词个数：" + Low_frequency_word_counter);
		System.out.println("去低频词后的数据向量大小：" +  dataVector.size());
					
		// 创建足够多的叶子节点用于构造二叉树，构建count个叶子节点
		int count = 4096;// 构建树使用的节点数量
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建count个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
//			if(file.exists()) {
			if(i<4000) {   //构建树使用的文件数量
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					// 只为数据向量中存在的词计算swf
					if (DataVector.get(word) != null) {
						double tfw = tfws.get(word);
						double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//						System.out.println("数据Di swf:" + swf);
						DataVector.put(word, swf);
					}
				}
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
//		System.out.println("DataVector的大小："+DataVector.size());
//		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
//		CreatBTree(HeadNode,LeafNodes);
//		CreateBTree1(HeadNode,LeafNodes);
		CreateBTree2(HeadNode,LeafNodes);
//		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
//		System.out.println("密钥向量S：" + S);
		
		
		long etime1 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime1-stime1));
		//自定义可逆矩阵M1，M2
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		long etime2 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime2-stime1));
					
		//放到线程池中执行多线程会快些
		EncryptNode Encry_headNode =new EncryptNode();
		EncrytBTree(S,M1,M2, HeadNode,Encry_headNode);
		
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime3 = System.currentTimeMillis();
//		System.out.printf("执行时长：%d毫秒", (etime1-stime1)+(etime2-stime2));
		System.out.printf("执行时长：%d毫秒", (etime3-stime1));	
			
	}
	


	/**
	 * 根据密钥S,M1,M2分裂树中所有D向量，构建加密树，返回加密树的头节点
	 * @return 
	 * 
	 */
	private static void EncrytBTree(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, LeafNode Node,
			EncryptNode encry_Node) {
		nodecount++;
		System.out.println("nodecount:"+ nodecount);
		Collection<Vector<Double>> Iu = new Vector<>() ;// 计算Iu={m1Td1，m2Td2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 | Node.D.get(i)==0) {  //S[i]=0 
				d1.add(Node.D.get(i));
				d2.add(Node.D.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
//				System.out.println("Node.D.get(i):"+Node.D.get(i));
				double a = Math.abs(rand.nextDouble(Node.D.get(i)));
				double b = Node.D.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		long etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长1：%d毫秒\n", (etime4-stime1));
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		Iu.add(m1T.mult(d1));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长2：%d毫秒\n", (etime4-stime1));
		Iu.add(m2T.mult(d2));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长3：%d毫秒\n", (etime4-stime1));
		
		// 创建加密树节点
		EncryptNode e_lnode = new EncryptNode();
		EncryptNode e_rnode = new EncryptNode();
		
		// 为加密树节点添加数据
		encry_Node.setIu(Iu);
		if(Node.Lchild==null&Node.Rchild==null) {// 左右子节点为空，则为叶子节点
			encry_Node.setFid(Node.Fid);// 为叶子节点加入Fid
		}
		encry_Node.setLchild(e_lnode);
		encry_Node.setRchild(e_rnode);
//		System.out.println("encry_Node.Iu:"+encry_Node.getIu());
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长4：%d毫秒\n", (etime4-stime1));
		//递归构建加密树
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Lchild,e_lnode);
		}
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Rchild,e_rnode);
		}
						
	}

	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量  Note: unused.
	 * @return 
	 * 
	 */
	private static Collection<Vector<Double>> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector<Double>> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		ColD.add(m1T.mult(d1));
		ColD.add(m2T.mult(d2));
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		long stime = System.currentTimeMillis();
		int count = 0;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(2000)-1000);
					m[i][j] = r;
				}
			}
			// 计算构建一次矩阵的耗时
			if(count ==1) {
				long etime = System.currentTimeMillis();
				System.out.printf("构建可逆矩阵执行时长：%d毫秒\n", (etime-stime));
			}
			
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
			count++;
		}
//		matrix.show();
		
		
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< DataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接根节点的左孩子节点
					headNode.Rchild=rNode;// 连接根节点的右孩子节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}
	
	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
	private static void CreateBTree2(LeafNode headNode, LeafNode[] leafNodes) {
		if(leafNodes.length == 2) {
			headNode.Lchild=leafNodes[0];// 连接根节点的左孩子节点
			headNode.Rchild=leafNodes[1];// 连接根节点的右孩子节点
			//通过左右节点的数据D计算中间节点的数据D
			for(int j = 0;j<leafNodes[0].D.size();j++) {
				double Di ; 
				if(leafNodes[0].D.get(j) > leafNodes[1].D.get(j)) {
					headNode.D.add(leafNodes[0].D.get(j));
				}else {
					headNode.D.add(leafNodes[1].D.get(j));
				}
			}
		}
		else {
			LeafNode[] midNodes = null ;
			if (leafNodes.length%2==0){//节点数为偶数时
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}else {//节点数为奇数时
				LeafNode lNode = leafNodes[i];//获取左节点
				
				midNodes[int ((leafNodes.length)/2]=leafNodes[leafNodes.length-1];
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
		
	}

	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
//	private static void CreateBTree1(LeafNode headNode, LeafNode[] leafNodes) {
//		LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
//		while(leafNodes.length > 1) {
//			//叶子节点数为偶数
//			if(leafNodes.length/2==0) {  
//				for(int i=0;i<leafNodes.length;i=i+2) {
//					LeafNode lNode = leafNodes[i];//获取左节点
//					LeafNode rNode = leafNodes[i+1];//获取右节点
//					int count = lNode.D.size();
//					
//					if(leafNodes.length == 2) {  //最后两个节点
//						//通过左右节点的数据D计算中间节点的数据D
//						for(int j = 0;j<count;j++) {
//							double Di ; 
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							headNode.D.add(Di);
//						}
//						headNode.Lchild=lNode;// 连接根节点的左孩子节点
//						headNode.Rchild=rNode;// 连接根节点的右孩子节点
//					}else {
//						//通过左右节点的数据D计算中间节点的数据D
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode;// 连接左节点
//						midNode.Rchild=rNode;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
//					}
//				}
//			//叶子节点数为奇数
//			}else{		
//				for(int i=0;i<leafNodes.length-3;i=i+2) {
//					LeafNode lNode0 = leafNodes[i];//获取左节点
//					LeafNode rNode0 = leafNodes[i+1];//获取右节点
//					
//					LeafNode u1 = new LeafNode(); //为前两个节点创建父节点u1
//					int count = lNode0.D.size();
//					//只剩3个节点
//					if(leafNodes.length == 3) {  
//						for(int k=0;k<leafNodes.length;k=k+2) {
//							for(int j = 0;j<count;j++) {
//								double Di ; 
//								if(leafNodes[k].D.get(j) > leafNodes[k+1].D.get(j)) {
//									Di = leafNodes[k].D.get(j);
//								}else {
//									Di = leafNodes[k+1].D.get(j);
//								}
//								u1.D.add(Di);
//							}
//							u1.Lchild=leafNodes[k];
//							u1.Rchild=leafNodes[k+1];	
//							
//							for(int j = 0;j<count;j++) {
//								double Dii ; 
//								if(u1.D.get(j) > leafNodes[k+2].D.get(j)) {
//									Dii = u1.D.get(j);
//								}else {
//									Dii = leafNodes[k+2].D.get(j);
//								}
//								headNode.D.add(Dii);
//							}
//							headNode.Lchild=u1;
//							headNode.Rchild=leafNodes[k+2];
//						}
//					}else {
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode0.D.get(j) > rNode0.D.get(j)) {
//								Di = lNode0.D.get(j);
//							}else {
//								Di = rNode0.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode0;// 连接左节点
//						midNode.Rchild=rNode0;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[(int) Math.ceil(i/2)]=midNode;// 向上取整，将中间节点放入数组中用于递归构建上一次中间节点
//						
//					}
//				}
//			}
//			System.out.println(" ");
//			CreateBTree1(headNode,midNodes); //递归调用
//		}
//		
//	}


	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-24 22:20:14.005
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-24 22:20:14.005
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-24 22:20:14.144
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ejml.simple.SimpleMatrix;
import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;
/**
 * @author 20680
 *
 */


//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable DataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	static long stime1;
	static int nodecount;
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		stime1 = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFC9056\\";// 我要遍历指定地址下的文件
		int fileAmount = 4000;// 构建关键词使用的文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		Map<String, Integer> Word_Count_Dictionary = new TreeMap<String, Integer>();// 构建字典（包含word词的文件个数）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式,获取关键字集及映射的数据向量（向量大小）
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
					Word_Count_Dictionary.put(word, 1);
				} else {
					Word_Count_Dictionary.put(word, Word_Count_Dictionary.get(word) + 1);
				}
			}
			
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
		}
//		System.out.println("Word_Count_Dictionary：" + Word_Count_Dictionary);
		

		double Lave = Lcount / fileAmount;
//		System.out.println("数据向量格式：" + dataVector);
//		System.out.println("数据向量大小：" + dataVector.size());
//		System.out.println("所有文档字符总数Lcount:" + Lcount);
//		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		System.out.println("原数据向量大小：" + dataVector.size());
		// 数据向量去低频词
		int Low_frequency_word_counter = 0;
		for(String word : Word_Count_Dictionary.keySet() ) {
//			double lf = fileAmount*0.1;
			double lf = 365;
			// 记录低频词的数量，并将其从数据向量中移除
			if (Word_Count_Dictionary.get(word) <= lf) {
				Low_frequency_word_counter += 1;
				dataVector.remove(word);
			}
		}
		System.out.println("低频单词个数：" + Low_frequency_word_counter);
		System.out.println("去低频词后的数据向量大小：" +  dataVector.size());
					
		// 创建足够多的叶子节点用于构造二叉树，构建count个叶子节点
		int count = 4096;// 构建树使用的节点数量
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建count个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
//			if(file.exists()) {
			if(i<4000) {   //构建树使用的文件数量
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					// 只为数据向量中存在的词计算swf
					if (DataVector.get(word) != null) {
						double tfw = tfws.get(word);
						double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//						System.out.println("数据Di swf:" + swf);
						DataVector.put(word, swf);
					}
				}
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
//		System.out.println("DataVector的大小："+DataVector.size());
//		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
//		CreatBTree(HeadNode,LeafNodes);
//		CreateBTree1(HeadNode,LeafNodes);
		CreateBTree2(HeadNode,LeafNodes);
//		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
//		System.out.println("密钥向量S：" + S);
		
		
		long etime1 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime1-stime1));
		//自定义可逆矩阵M1，M2
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		long etime2 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime2-stime1));
					
		//放到线程池中执行多线程会快些
		EncryptNode Encry_headNode =new EncryptNode();
		EncrytBTree(S,M1,M2, HeadNode,Encry_headNode);
		
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime3 = System.currentTimeMillis();
//		System.out.printf("执行时长：%d毫秒", (etime1-stime1)+(etime2-stime2));
		System.out.printf("执行时长：%d毫秒", (etime3-stime1));	
			
	}
	


	/**
	 * 根据密钥S,M1,M2分裂树中所有D向量，构建加密树，返回加密树的头节点
	 * @return 
	 * 
	 */
	private static void EncrytBTree(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, LeafNode Node,
			EncryptNode encry_Node) {
		nodecount++;
		System.out.println("nodecount:"+ nodecount);
		Collection<Vector<Double>> Iu = new Vector<>() ;// 计算Iu={m1Td1，m2Td2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 | Node.D.get(i)==0) {  //S[i]=0 
				d1.add(Node.D.get(i));
				d2.add(Node.D.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
//				System.out.println("Node.D.get(i):"+Node.D.get(i));
				double a = Math.abs(rand.nextDouble(Node.D.get(i)));
				double b = Node.D.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		long etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长1：%d毫秒\n", (etime4-stime1));
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		Iu.add(m1T.mult(d1));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长2：%d毫秒\n", (etime4-stime1));
		Iu.add(m2T.mult(d2));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长3：%d毫秒\n", (etime4-stime1));
		
		// 创建加密树节点
		EncryptNode e_lnode = new EncryptNode();
		EncryptNode e_rnode = new EncryptNode();
		
		// 为加密树节点添加数据
		encry_Node.setIu(Iu);
		if(Node.Lchild==null&Node.Rchild==null) {// 左右子节点为空，则为叶子节点
			encry_Node.setFid(Node.Fid);// 为叶子节点加入Fid
		}
		encry_Node.setLchild(e_lnode);
		encry_Node.setRchild(e_rnode);
//		System.out.println("encry_Node.Iu:"+encry_Node.getIu());
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长4：%d毫秒\n", (etime4-stime1));
		//递归构建加密树
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Lchild,e_lnode);
		}
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Rchild,e_rnode);
		}
						
	}

	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量  Note: unused.
	 * @return 
	 * 
	 */
	private static Collection<Vector<Double>> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector<Double>> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		ColD.add(m1T.mult(d1));
		ColD.add(m2T.mult(d2));
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		long stime = System.currentTimeMillis();
		int count = 0;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(2000)-1000);
					m[i][j] = r;
				}
			}
			// 计算构建一次矩阵的耗时
			if(count ==1) {
				long etime = System.currentTimeMillis();
				System.out.printf("构建可逆矩阵执行时长：%d毫秒\n", (etime-stime));
			}
			
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
			count++;
		}
//		matrix.show();
		
		
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< DataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接根节点的左孩子节点
					headNode.Rchild=rNode;// 连接根节点的右孩子节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}
	
	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
	private static void CreateBTree2(LeafNode headNode, LeafNode[] leafNodes) {
		if(leafNodes.length == 2) {
			headNode.Lchild=leafNodes[0];// 连接根节点的左孩子节点
			headNode.Rchild=leafNodes[1];// 连接根节点的右孩子节点
			//通过左右节点的数据D计算中间节点的数据D
			for(int j = 0;j<leafNodes[0].D.size();j++) {
				double Di ; 
				if(leafNodes[0].D.get(j) > leafNodes[1].D.get(j)) {
					headNode.D.add(leafNodes[0].D.get(j));
				}else {
					headNode.D.add(leafNodes[1].D.get(j));
				}
			}
		}
		else {
			LeafNode[] midNodes = null ;
			if (leafNodes.length%2==0){//节点数为偶数时
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}else {//节点数为奇数时
				LeafNode lNode = leafNodes[i];//获取左节点
				
				midNodes[int ((leafNodes.length)/2]=leafNodes[leafNodes.length-1];
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
		
	}

	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
//	private static void CreateBTree1(LeafNode headNode, LeafNode[] leafNodes) {
//		LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
//		while(leafNodes.length > 1) {
//			//叶子节点数为偶数
//			if(leafNodes.length/2==0) {  
//				for(int i=0;i<leafNodes.length;i=i+2) {
//					LeafNode lNode = leafNodes[i];//获取左节点
//					LeafNode rNode = leafNodes[i+1];//获取右节点
//					int count = lNode.D.size();
//					
//					if(leafNodes.length == 2) {  //最后两个节点
//						//通过左右节点的数据D计算中间节点的数据D
//						for(int j = 0;j<count;j++) {
//							double Di ; 
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							headNode.D.add(Di);
//						}
//						headNode.Lchild=lNode;// 连接根节点的左孩子节点
//						headNode.Rchild=rNode;// 连接根节点的右孩子节点
//					}else {
//						//通过左右节点的数据D计算中间节点的数据D
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode;// 连接左节点
//						midNode.Rchild=rNode;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
//					}
//				}
//			//叶子节点数为奇数
//			}else{		
//				for(int i=0;i<leafNodes.length-3;i=i+2) {
//					LeafNode lNode0 = leafNodes[i];//获取左节点
//					LeafNode rNode0 = leafNodes[i+1];//获取右节点
//					
//					LeafNode u1 = new LeafNode(); //为前两个节点创建父节点u1
//					int count = lNode0.D.size();
//					//只剩3个节点
//					if(leafNodes.length == 3) {  
//						for(int k=0;k<leafNodes.length;k=k+2) {
//							for(int j = 0;j<count;j++) {
//								double Di ; 
//								if(leafNodes[k].D.get(j) > leafNodes[k+1].D.get(j)) {
//									Di = leafNodes[k].D.get(j);
//								}else {
//									Di = leafNodes[k+1].D.get(j);
//								}
//								u1.D.add(Di);
//							}
//							u1.Lchild=leafNodes[k];
//							u1.Rchild=leafNodes[k+1];	
//							
//							for(int j = 0;j<count;j++) {
//								double Dii ; 
//								if(u1.D.get(j) > leafNodes[k+2].D.get(j)) {
//									Dii = u1.D.get(j);
//								}else {
//									Dii = leafNodes[k+2].D.get(j);
//								}
//								headNode.D.add(Dii);
//							}
//							headNode.Lchild=u1;
//							headNode.Rchild=leafNodes[k+2];
//						}
//					}else {
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode0.D.get(j) > rNode0.D.get(j)) {
//								Di = lNode0.D.get(j);
//							}else {
//								Di = rNode0.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode0;// 连接左节点
//						midNode.Rchild=rNode0;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[(int) Math.ceil(i/2)]=midNode;// 向上取整，将中间节点放入数组中用于递归构建上一次中间节点
//						
//					}
//				}
//			}
//			System.out.println(" ");
//			CreateBTree1(headNode,midNodes); //递归调用
//		}
//		
//	}


	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-24 22:20:14.144
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-24 22:20:14.145
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-24 22:20:16.063
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.btg.core.util.bbm25;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random; //
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ejml.simple.SimpleMatrix;
import org.wltea.analyzer.core.IKSegmenter;
import org.wltea.analyzer.core.Lexeme;
/**
 * @author 20680
 *
 */


//定义节点类
public class LeafNode {
	//  调节因子
	private static final double k1 = 1.5;
	private static final double b = 0.75;
	
	private int id = 0;// 节点id
	private Vector<Double> D = new Vector<>(); // 构建数据向量  
	private static Hashtable DataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
//	private int Lf = 0;  // 该节点文档字符总数
//	private static int Lave = 0;  // 所有节点文档的平均字符数
	private LeafNode Lchild = null;
	private LeafNode Rchild = null;
	private String Fid = null;

	// 构造函数,创建节点时自动生成id
	public LeafNode() {
		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
	}

	// 给节点编号
	public int setID() {
		// TODO Auto-generated method stub

		Random rand1 = new Random();
		id = Math.abs(rand1.nextInt(1000)); // 0-1000之间的随机数
		return id;
	}
	
	//为向量构建大小
	
	// 给数据向量赋值
	public Vector<Double> setD(double data[]) {
		// Vector<String> D = new Vector<>();
		for (int i = 0; i < data.length; i++) {
//			D.add(Double.toString(data[i]));
//			D.add(2, "0.5362");
		}
		return D;
	}

	// 设置节点的指针指向 左孩子
	public LeafNode setLchild() {
		// 若节点为叶子节点
		Lchild = null;
		return Lchild;
	}

	// 设置节点的指针指向 右孩子
	public LeafNode setRchild() {
		Rchild = null;
		return Rchild;
	}

	static long stime1;
	static int nodecount;
	
	// 主函数
	public static void main(String[] args) throws Exception {	
		//运行开始时间
		stime1 = System.currentTimeMillis();
		
		String path = "D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFC9056\\";// 我要遍历指定地址下的文件
		int fileAmount = 4000;// 构建关键词使用的文件数量
		//第一次遍历所有文件，计算文档字符数Lcount，构建关键词向量格式
		double Lcount = 0.0;// 所有文档字符数
		Hashtable dataVector = new Hashtable(); // 构建向量（字典类型保存数据向量）
		Map<String, Integer> Word_Count_Dictionary = new TreeMap<String, Integer>();// 构建字典（包含word词的文件个数）
		for (int i = 1; i <= fileAmount; i++) {
			String fileName = "rfc" + i + ".txt";// 获取文件名
			Map<List<String>,Integer> words_lf = Words_Lf(path + fileName);// 查询文档中的非停用词，和文档字符数
			//遍历所有文件构造节点向量格式,获取关键字集及映射的数据向量（向量大小）
			Set<List<String>> wordsList = words_lf.keySet();
			List<String> wordslist = (List<String>) wordsList.toArray()[0];
//			System.out.println("wordsList：" + wordslist);
			for(String word:wordslist) {
				if (dataVector.get(word) == null) {
					dataVector.put(word, 0.0);
					Word_Count_Dictionary.put(word, 1);
				} else {
					Word_Count_Dictionary.put(word, Word_Count_Dictionary.get(word) + 1);
				}
			}
			
			
			// 遍历计算所有文档字符数
			Collection<Integer> Lfs = words_lf.values();
			Iterator<Integer> lfs = Lfs.iterator();
			while(lfs.hasNext()){ //判断是否有迭代元素
	            Integer s = lfs.next();//获取迭代出的元素
	            Lcount += s;
//	            System.out.println("第" + i + "个文件的字符数Lf=" + s);
	        }
		}
//		System.out.println("Word_Count_Dictionary：" + Word_Count_Dictionary);
		

		double Lave = Lcount / fileAmount;
//		System.out.println("数据向量格式：" + dataVector);
//		System.out.println("数据向量大小：" + dataVector.size());
//		System.out.println("所有文档字符总数Lcount:" + Lcount);
//		System.out.println("所有文档平均字符数Lave:" + Lave);
		
		System.out.println("原数据向量大小：" + dataVector.size());
		// 数据向量去低频词
		int Low_frequency_word_counter = 0;
		for(String word : Word_Count_Dictionary.keySet() ) {
//			double lf = fileAmount*0.1;
			double lf = 365;
			// 记录低频词的数量，并将其从数据向量中移除
			if (Word_Count_Dictionary.get(word) <= lf) {
				Low_frequency_word_counter += 1;
				dataVector.remove(word);
			}
		}
		System.out.println("低频单词个数：" + Low_frequency_word_counter);
		System.out.println("去低频词后的数据向量大小：" +  dataVector.size());
					
		// 创建足够多的叶子节点用于构造二叉树，构建count个叶子节点
		int count = 4096;// 构建树使用的节点数量
		LeafNode[] LeafNodes = new LeafNode[count];// 创建用于存放叶子节点对象的数组
		// 循环构建count个叶子节点
		for (int i = 0; i < count; i++){
			LeafNode leafnode = new LeafNode();// 新建叶子节点
//			System.out.println("当前叶子节点id:" + leafnode.id);
			String fileName = "rfc" + (i+1) + ".txt";// 获取文件名
			// 判断该文件是否存在，存在则计算叶子节点向量的数值 S(w,f) 并将数据赋予叶子节点
			File file = new File(path + fileName);
//			if(file.exists()) {
			if(i<4000) {   //构建树使用的文件数量
//				System.out.printf("存在%s文件\n" , fileName);
				Map<Map<String, Double>, Integer> tfws_L = Cal_tfw(path + fileName);// 获取该文件的词频字典 tfws 和字符数 Lf
				// 获取当前文档字符数Lf
				double  Lf = 0.0;
				Collection<Integer> ColLf = tfws_L.values();
				Iterator<Integer> Itlf = ColLf.iterator();
				while(Itlf.hasNext()){ //判断是否有迭代元素
					Lf = Itlf.next();//获取迭代出的元素
		        }	
//				System.out.println("当前文档字符数Lf=" + Lf);
				
				// 获取该文件的词频字典 tfw
				Set<Map<String, Double>> Settfw = tfws_L.keySet();
				Map<String, Double> tfws = Settfw.iterator().next();// 获取词频字典 tfws
//				System.out.println("词频字典tfws:" + tfws);
//				System.out.println("词频字典大小:" + tfws.size());
//				System.out.println();
				
				// 遍历词频字典计算向量的数值 S(w,f)
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
//				System.out.println("词频字典大小:" + tfws.size());
				for(String word:tfws.keySet()) {
					// 只为数据向量中存在的词计算swf
					if (DataVector.get(word) != null) {
						double tfw = tfws.get(word);
						double swf = ((k1+1)*tfw)/(k1*(1-b+b*(Lf/Lave)));
//						System.out.println("数据Di swf:" + swf);
						DataVector.put(word, swf);
					}
				}
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				leafnode.Fid = fileName;
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
//				System.out.println("leafnode.D的大小："+leafnode.D.size());
//				System.out.println("leafnode.dataVector的大小："+leafnode.dataVector.size());
//				System.out.println("输出叶子节点内容： id:" + LeafNodes[i].id +" Fid:"+ LeafNodes[i].Fid + " D:"+ LeafNodes[i].D + " ");
			
				
			}else {
//				System.out.printf("不存在%s文件\n" , fileName);
				DataVector.putAll(dataVector);// 为节点数据向量创建格式
				leafnode.D.addAll(DataVector.values());//将dataVector中的swf值 传递给D向量
				LeafNodes[i] = leafnode;//将叶子节点存入数组中，用于之后二叉树的构建
				
			}
		}
//		System.out.println("DataVector的大小："+DataVector.size());
//		System.out.println("已创建的叶子节点个数：" + LeafNodes.length);
		
		//构建二叉树
		LeafNode HeadNode = new LeafNode();
//		CreatBTree(HeadNode,LeafNodes);
//		CreateBTree1(HeadNode,LeafNodes);
		CreateBTree2(HeadNode,LeafNodes);
//		System.out.println("HeadNode:"+HeadNode.D);
		
		
		//加密索引二叉树，即加密数据向量D
		Vector<Integer> S = new Vector<>();
		S = setS();
//		System.out.println("密钥向量S：" + S);
		
		
		long etime1 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime1-stime1));
		//自定义可逆矩阵M1，M2
		BaseMatrix M1 = setMatrix(dataVector.size(),dataVector.size());
		BaseMatrix M2 = setMatrix(dataVector.size(),dataVector.size());
		long etime2 = System.currentTimeMillis();
		System.out.printf("执行时长：%d毫秒\n", (etime2-stime1));
					
		//放到线程池中执行多线程会快些
		EncryptNode Encry_headNode =new EncryptNode();
		EncrytBTree(S,M1,M2, HeadNode,Encry_headNode);
		
		
		//运行结束时间，输出运行总时长
		System.out.println();
		long etime3 = System.currentTimeMillis();
//		System.out.printf("执行时长：%d毫秒", (etime1-stime1)+(etime2-stime2));
		System.out.printf("执行时长：%d毫秒", (etime3-stime1));	
			
	}
	


	/**
	 * 根据密钥S,M1,M2分裂树中所有D向量，构建加密树，返回加密树的头节点
	 * @return 
	 * 
	 */
	private static void EncrytBTree(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, LeafNode Node,
			EncryptNode encry_Node) {
		nodecount++;
		System.out.println("nodecount:"+ nodecount);
		Collection<Vector<Double>> Iu = new Vector<>() ;// 计算Iu={m1Td1，m2Td2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 | Node.D.get(i)==0) {  //S[i]=0 
				d1.add(Node.D.get(i));
				d2.add(Node.D.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
//				System.out.println("Node.D.get(i):"+Node.D.get(i));
				double a = Math.abs(rand.nextDouble(Node.D.get(i)));
				double b = Node.D.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		long etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长1：%d毫秒\n", (etime4-stime1));
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		Iu.add(m1T.mult(d1));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长2：%d毫秒\n", (etime4-stime1));
		Iu.add(m2T.mult(d2));
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长3：%d毫秒\n", (etime4-stime1));
		
		// 创建加密树节点
		EncryptNode e_lnode = new EncryptNode();
		EncryptNode e_rnode = new EncryptNode();
		
		// 为加密树节点添加数据
		encry_Node.setIu(Iu);
		if(Node.Lchild==null&Node.Rchild==null) {// 左右子节点为空，则为叶子节点
			encry_Node.setFid(Node.Fid);// 为叶子节点加入Fid
		}
		encry_Node.setLchild(e_lnode);
		encry_Node.setRchild(e_rnode);
//		System.out.println("encry_Node.Iu:"+encry_Node.getIu());
		etime4 = System.currentTimeMillis();
//		System.out.printf("执行时长4：%d毫秒\n", (etime4-stime1));
		//递归构建加密树
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Lchild,e_lnode);
		}
		if(Node.Lchild!=null){
			EncrytBTree(s,m1,m2, Node.Rchild,e_rnode);
		}
						
	}

	/**
	 * 根据密钥S,M1,M2分裂D向量，返回[M1D1,M2D2]向量  Note: unused.
	 * @return 
	 * 
	 */
	private static Collection<Vector<Double>> SplitD1(Vector<Integer> s, BaseMatrix m1, BaseMatrix m2, Vector<Double> d) {
		Collection<Vector<Double>> ColD = new Vector<>() ;  //存放{d1,d2}
		Vector<Double> d1 = new Vector<>();
		Vector<Double> d2 = new Vector<>();
		Random rand = new Random();
		// S分裂D 
		for(int i=0;i<s.size();i++) {
			int ss = s.get(i);
			if(ss != 1 ) {  //S[i]=0 
				d1.add(d.get(i));
				d2.add(d.get(i));
			}
			else {//S[i]=1  d1[i]+d2[i]=d[i]
				double a = Math.abs(rand.nextDouble(d.get(i)));
				double b = d.get(i)-a;
				d1.add(a);
				d2.add(b);
			}
		}
		// 矩阵加密D1和D2
		BaseMatrix m1T = m1.reverse();// 转置m1矩阵
		BaseMatrix m2T = m2.reverse();// 转置m2矩阵
		
//		BaseMatrix m1_1 =  m1.invert();//求逆矩阵
		// 计算Iu={m1Td1，m2Td2}
		ColD.add(m1T.mult(d1));
		ColD.add(m2T.mult(d2));
		return ColD;
	}

	
	

	/**
	 * 自定义可逆矩阵M1,M2（密钥向量） 
	 * 输入行数和列数，Random随机生成所有值
	 * @return 
	 */
	public static BaseMatrix setMatrix(int column, int row) {
		double [][] m = new double[column][row];
		int col,rw; //分别声明矩阵的行数和列数
		BaseMatrix matrix = null;
//		Scanner s=new Scanner(System.in); //终端输入矩阵中的值
		Random rand3 = new Random();
		//构建可逆矩阵
		boolean isinvertible = false;
		long stime = System.currentTimeMillis();
		int count = 0;
		while(!isinvertible) {//判断是否可逆，不可逆重新构建矩阵
			for(int i=0;i<column;i++) {
				for(int j=0;j<row;j++) {
					double r = Math.abs(rand3.nextDouble(2000)-1000);
					m[i][j] = r;
				}
			}
			// 计算构建一次矩阵的耗时
			if(count ==1) {
				long etime = System.currentTimeMillis();
				System.out.printf("构建可逆矩阵执行时长：%d毫秒\n", (etime-stime));
			}
			
			//判断矩阵是否可逆
			matrix = new BaseMatrix(m);
			isinvertible = matrix.IsInvertible(column);
			count++;
		}
//		matrix.show();
		
		
		
		return matrix;
	}

	/**
	 * 生成随机二进制串S（密钥向量） 
	 * 
	 * @return 
	 */
	public static Vector<Integer> setS() {
		Vector<Integer> SV = new Vector<>();
		Random rand2 = new Random();	
		int s;
		for(int i=0;i< DataVector.size();i++)  //如何设置 使得密钥向量S的大小与数据向量D的大小一致
			{
				s=(int)Math.abs(rand2.nextInt(2)); // 0-1
				SV.add(s);
			}
		return SV;
	}

	/**
	 * 输入叶子节点数组leafNodes和头节点headNode，构建二叉树
	 * 
	 * @return 
	 */
	private static void CreatBTree(LeafNode headNode, LeafNode[] leafNodes) {
		//如果列表中的中间节点不止1个节点，则两两节点合并，构建上一层中间节点
		if(leafNodes.length > 1) {
			LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
			for(int i=0;i<leafNodes.length;i=i+2) {
				LeafNode lNode = leafNodes[i];//获取左节点
				LeafNode rNode = leafNodes[i+1];//获取右节点
				
				int count = lNode.D.size();
				// 剩下最后两个节点，直接指向头节点；否则创建中间节点连接左右字节点
				if(leafNodes.length == 2) {
					//通过左右节点的数据D计算中间节点的数据D
					for(int j = 0;j<count;j++) {
						double Di ; 
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						headNode.D.add(Di);
					}
					headNode.Lchild=lNode;// 连接根节点的左孩子节点
					headNode.Rchild=rNode;// 连接根节点的右孩子节点
				}else {
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
				
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
	}
	
	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
	private static void CreateBTree2(LeafNode headNode, LeafNode[] leafNodes) {
		if(leafNodes.length == 2) {
			headNode.Lchild=leafNodes[0];// 连接根节点的左孩子节点
			headNode.Rchild=leafNodes[1];// 连接根节点的右孩子节点
			//通过左右节点的数据D计算中间节点的数据D
			for(int j = 0;j<leafNodes[0].D.size();j++) {
				double Di ; 
				if(leafNodes[0].D.get(j) > leafNodes[1].D.get(j)) {
					headNode.D.add(leafNodes[0].D.get(j));
				}else {
					headNode.D.add(leafNodes[1].D.get(j));
				}
			}
		}
		else {
			LeafNode[] midNodes = null ;
			if (leafNodes.length%2==0){//节点数为偶数时
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}else {//节点数为奇数时
				LeafNode lNode = leafNodes[i];//获取左节点
				
				midNodes[int ((leafNodes.length)/2]=leafNodes[leafNodes.length-1];
				for(int i=0;i<leafNodes.length;i=i+2) {
					LeafNode lNode = leafNodes[i];//获取左节点
					LeafNode rNode = leafNodes[i+1];//获取右节点
					
					int count = lNode.D.size();
					//通过左右节点的数据D计算中间节点的数据D
					LeafNode midNode = new LeafNode();
					for(int j = 0;j<count;j++) {
						double Di ; 
//						System.out.println(j);
//						System.out.println(count);
						if(lNode.D.get(j) > rNode.D.get(j)) {
							Di = lNode.D.get(j);
						}else {
							Di = rNode.D.get(j);
						}
						midNode.D.add(Di);
					}
					midNode.Lchild=lNode;// 连接左节点
					midNode.Rchild=rNode;// 连接右节点
//					System.out.println("midNode.D:"+i+midNode.D);
					midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
				}
			}
			System.out.println(" ");
//			System.out.println(midNodes);
			CreatBTree(headNode,midNodes);
		}
		
	}

	/**
	 * 另一种构建二叉树的方法BDMRS
	 * 
	 * @throws IOException 
	 */
//	private static void CreateBTree1(LeafNode headNode, LeafNode[] leafNodes) {
//		LeafNode[] midNodes = new LeafNode[(leafNodes.length)/2];
//		while(leafNodes.length > 1) {
//			//叶子节点数为偶数
//			if(leafNodes.length/2==0) {  
//				for(int i=0;i<leafNodes.length;i=i+2) {
//					LeafNode lNode = leafNodes[i];//获取左节点
//					LeafNode rNode = leafNodes[i+1];//获取右节点
//					int count = lNode.D.size();
//					
//					if(leafNodes.length == 2) {  //最后两个节点
//						//通过左右节点的数据D计算中间节点的数据D
//						for(int j = 0;j<count;j++) {
//							double Di ; 
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							headNode.D.add(Di);
//						}
//						headNode.Lchild=lNode;// 连接根节点的左孩子节点
//						headNode.Rchild=rNode;// 连接根节点的右孩子节点
//					}else {
//						//通过左右节点的数据D计算中间节点的数据D
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode.D.get(j) > rNode.D.get(j)) {
//								Di = lNode.D.get(j);
//							}else {
//								Di = rNode.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode;// 连接左节点
//						midNode.Rchild=rNode;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[i/2]=midNode;// 将中间节点放入数组中用于递归构建上一次中间节点
//					}
//				}
//			//叶子节点数为奇数
//			}else{		
//				for(int i=0;i<leafNodes.length-3;i=i+2) {
//					LeafNode lNode0 = leafNodes[i];//获取左节点
//					LeafNode rNode0 = leafNodes[i+1];//获取右节点
//					
//					LeafNode u1 = new LeafNode(); //为前两个节点创建父节点u1
//					int count = lNode0.D.size();
//					//只剩3个节点
//					if(leafNodes.length == 3) {  
//						for(int k=0;k<leafNodes.length;k=k+2) {
//							for(int j = 0;j<count;j++) {
//								double Di ; 
//								if(leafNodes[k].D.get(j) > leafNodes[k+1].D.get(j)) {
//									Di = leafNodes[k].D.get(j);
//								}else {
//									Di = leafNodes[k+1].D.get(j);
//								}
//								u1.D.add(Di);
//							}
//							u1.Lchild=leafNodes[k];
//							u1.Rchild=leafNodes[k+1];	
//							
//							for(int j = 0;j<count;j++) {
//								double Dii ; 
//								if(u1.D.get(j) > leafNodes[k+2].D.get(j)) {
//									Dii = u1.D.get(j);
//								}else {
//									Dii = leafNodes[k+2].D.get(j);
//								}
//								headNode.D.add(Dii);
//							}
//							headNode.Lchild=u1;
//							headNode.Rchild=leafNodes[k+2];
//						}
//					}else {
//						LeafNode midNode = new LeafNode();
//						for(int j = 0;j<count;j++) {
//							double Di ; 
////							System.out.println(j);
////							System.out.println(count);
//							if(lNode0.D.get(j) > rNode0.D.get(j)) {
//								Di = lNode0.D.get(j);
//							}else {
//								Di = rNode0.D.get(j);
//							}
//							midNode.D.add(Di);
//						}
//						midNode.Lchild=lNode0;// 连接左节点
//						midNode.Rchild=rNode0;// 连接右节点
////						System.out.println("midNode.D:"+i+midNode.D);
//						midNodes[(int) Math.ceil(i/2)]=midNode;// 向上取整，将中间节点放入数组中用于递归构建上一次中间节点
//						
//					}
//				}
//			}
//			System.out.println(" ");
//			CreateBTree1(headNode,midNodes); //递归调用
//		}
//		
//	}


	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词词频字典 tfw 和该文档字符数 Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<Map<String, Double>, Integer> Cal_tfw(String fileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储文件中的所有英文单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> tfw_L = new HashMap<>();
		tfw_L.put(wordsFre, Lf);
		return tfw_L;
	}
	

	/**
	 * 输入文档位置 fileName，输出该文档中的非停用词列表wordsList 和文档字符数Lf
	 * 
	 * @return
	 * @throws IOException 
	 */
	private static Map<List<String>, Integer> Words_Lf(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
//			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}
	private static Map<List<String>, Integer> Words_Lf2(String fileName) throws IOException {
		Map<List<String>, Integer> wordsList = new HashMap<List<String>, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-[a-zA-Z]+)?";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//				System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		wordsList.put(lists, Lf);
		return wordsList;
	}

	/**
	 * 输入文档位置 fileName，输出该文档中的单词词频字典 WordFre
	 * 
	 * @return
	 */
	public static Map<Map<String, Double>, Integer> WordCount(String fileName) throws Exception {
//		BufferedReader br = new BufferedReader(new FileReader("D:\\PostGraduate\\要毕业\\SSE\\SSE草稿\\experiment\\RFC\\RFC\\RFCtxt(50)\\rfc53.txt"));  
		//找到所有英文单词存入列表 lists_all 中
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		List<String> lists_all1 = new ArrayList<String>(); // 存储过滤后单词的列表
		int Lf = 0; // 存储所有字符的个数
		String readLine = null;
		while ((readLine = br.readLine()) != null) {
			String regex1 = "[a-zA-Z]+(\\-)?[a-zA-Z]*";// 用于匹配英文单词的正则表达式
			List<String> wordsArr1 = getMatchers(regex1, readLine);//匹配该行的英文单词，保存在列表
			if(readLine.length() != 0) {
				Lf += readLine.replaceAll(" ","").length();
			}
			for (String word : wordsArr1) {
				if (word.length() != 0) { // 去除长度为0的行
					lists_all1.add(word);
				}
			}
		}
//		System.out.println("Lf:" + Lf);
//		System.out.println(lists_all);
		br.close();
		
		int N = lists_all1.size();// 统计该txt文件中的总单词数，即文档长度
//      System.out.println("文档总单词数：" +N);
		
		// 只取有效单词存入列表 lists 中
		String sentences = String.join(" ", lists_all1);// 拼接字符串列表为一个字符串
		List<String> lists = ikanalyzer(sentences);
//		System.out.println(sentences);
//		System.out.println("有效单词列表:" + lists);
		
		Map<String, Integer> wordsCount = new TreeMap<String, Integer>(); // 存储单词计数信息，key值为单词，value为单词数
		// 单词的词频（单词出现次数）统计，字典形式保存在wordsCount中
		for (String li : lists) {
			if (wordsCount.get(li) != null) {
				wordsCount.put(li, wordsCount.get(li) + 1);
			} else {
				wordsCount.put(li, 1);
			}

		}
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		Map<String, Double> wordsFre = new HashMap<String, Double>(); // 存储单词词频信息，key值为单词，value为单词在该文档中的频率
		Set<Entry<String, Integer>> set = wordsCount.entrySet();
		for (Entry<String, Integer> entry : set) {
	         String key = entry.getKey();
	         Double value = (double)entry.getValue();
//	         System.out.println(v);
//	         System.out.println(N);
	         Double tfw = value/N;// 计算词频
//	         System.out.println(key + " : " + tfw);
	         wordsFre.put(key, tfw);
	      }
		
		//词频 + 该文档字符总数
		Map<Map<String, Double>,Integer> S_w_f = new HashMap<>();
		S_w_f.put(wordsFre, Lf);
//		System.out.println(wordsFre);
		
		//词频（单词在所在文档中的占比）的计算，字典形式保存在wordsFre中
		//另一种方法
		/*
		Set<String> set = wordsCount.keySet();
	      for (String s : set) {
	         String key = s;
	         Integer value = wordsCount.get(s);
	         System.out.println(key + " : " + value);
	      }
	      */
		
		
		return S_w_f;
	}

	// 匹配source（字符串）中的所有英文单词，并按字符串数组输出
	public static List<String> getMatchers(String regex, String source) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(source);
		List<String> list = new ArrayList<>();
		while (matcher.find()) {
			list.add(matcher.group());

		}
//	      System.out.println(list);
		return list;
	}

	/**
	 * 分词:输入字符串（一句话），输出一个单词列表（有效单词）
	 * 
	 * @return
	 */
	private static List<String> ikanalyzer(String line) {
		StringReader re = new StringReader(line);
		IKSegmenter ik = new IKSegmenter(re, true);
		Lexeme lex = null;
		List<String> words = new ArrayList<>();
		try {
			while ((lex = ik.next()) != null) {
				String text = lex.getLexemeText();
				words.add(text);
			}
			return words;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return words;
	}
}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-24 22:20:16.064
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-24 22:20:16.064
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-02-25 14:27:23.884 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-25 14:27:29.095
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:27:29.095
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:27:29.095
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-25 14:27:33.567
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-25 14:28:22.641
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-25 14:35:37.681 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-25 14:35:41.567
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:35:41.568
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:35:41.568
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-25 14:35:43.987
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-25 14:35:58.696
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-25 14:45:58.972 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-25 14:46:03.965
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:46:03.965
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 14:46:03.965
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-25 14:46:06.459
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-25 14:46:14.318
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-25 20:28:35.282 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-25 20:28:42.307
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 20:28:42.307
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 20:28:42.307
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-25 20:28:44.632
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-25 20:28:52.295
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-25 22:32:02.971 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-25 22:32:07.153
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 22:32:07.153
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-25 22:32:07.153
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-25 22:32:09.891
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-25 22:32:20.358
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-02-26 10:38:19.672 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-26 10:38:29.513
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 10:38:29.513
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 10:38:29.513
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-26 10:38:31.946
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-26 10:38:39.888
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 10:41:20.724
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setDirty(LaunchConfigurationWorkingCopy.java:524)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setAttribute(LaunchConfigurationWorkingCopy.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:410)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 10:41:20.725
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 10:41:20.726
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setDirty(LaunchConfigurationWorkingCopy.java:524)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setAttribute(LaunchConfigurationWorkingCopy.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:411)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 10:41:20.726
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 10:41:20.728
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchManager.launchConfigurationChanged(LaunchManager.java:2147)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.writeNewFile(LaunchConfigurationWorkingCopy.java:377)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave0(LaunchConfigurationWorkingCopy.java:259)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave(LaunchConfigurationWorkingCopy.java:229)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave(LaunchConfigurationWorkingCopy.java:187)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 10:41:20.728
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!SESSION 2023-02-26 15:23:46.095 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-26 15:23:50.888
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 15:23:50.888
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 15:23:50.888
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-26 15:23:53.445
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-26 15:24:01.607
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 16:19:35.500
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setDirty(LaunchConfigurationWorkingCopy.java:524)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setAttribute(LaunchConfigurationWorkingCopy.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:410)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 16:19:35.500
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 16:19:35.501
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setDirty(LaunchConfigurationWorkingCopy.java:524)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.setAttribute(LaunchConfigurationWorkingCopy.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:411)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 16:19:35.501
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-02-26 16:19:35.503
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!STACK 1
org.eclipse.core.runtime.CoreException: Launch configuration LeafNode (1) references non-existing project ik-analyzer.
	at org.eclipse.jdt.launching.JavaRuntime.abort(JavaRuntime.java:1861)
	at org.eclipse.jdt.launching.JavaRuntime.getJavaProject(JavaRuntime.java:1736)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.updateLaunchConfiguration(MavenLaunchConfigurationListener.java:64)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.launchConfigurationChanged(MavenLaunchConfigurationListener.java:50)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:225)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:209)
	at org.eclipse.debug.internal.core.LaunchManager.launchConfigurationChanged(LaunchManager.java:2147)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.writeNewFile(LaunchConfigurationWorkingCopy.java:377)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave0(LaunchConfigurationWorkingCopy.java:259)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave(LaunchConfigurationWorkingCopy.java:229)
	at org.eclipse.debug.internal.core.LaunchConfigurationWorkingCopy.doSave(LaunchConfigurationWorkingCopy.java:187)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:412)
	at org.eclipse.m2e.jdt.internal.launch.MavenRuntimeClasspathProvider.disable(MavenRuntimeClasspathProvider.java:436)
	at org.eclipse.m2e.jdt.internal.launch.MavenLaunchConfigurationListener.mavenProjectChanged(MavenLaunchConfigurationListener.java:135)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.notifyProjectChangeListeners(ProjectRegistryManager.java:827)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryManager.applyMutableProjectRegistry(ProjectRegistryManager.java:982)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.lambda$0(ProjectRegistryRefreshJob.java:170)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:350)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:262)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:205)
	at org.eclipse.m2e.core.internal.project.registry.ProjectRegistryRefreshJob.run(ProjectRegistryRefreshJob.java:104)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.launching 4 107 2023-02-26 16:19:35.503
!MESSAGE Launch configuration LeafNode (1) references non-existing project ik-analyzer.
!SESSION 2023-02-26 16:44:44.280 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-26 16:44:57.128
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 16:44:57.128
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 16:44:57.128
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-26 16:44:59.400
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-26 16:45:07.268
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY com.codeaffine.archive.ui 4 0 2023-02-26 17:16:40.727
!MESSAGE zip END header not found
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at com.codeaffine.archive.ui.internal.model.ArchiveReader.openZipFile(ArchiveReader.java:49)
	at com.codeaffine.archive.ui.internal.model.ArchiveReader.read(ArchiveReader.java:39)
	at com.codeaffine.archive.ui.internal.model.ArchiveReader.read(ArchiveReader.java:21)
	at com.codeaffine.archive.ui.internal.viewer.ArchiveContentProvider.getChildren(ArchiveContentProvider.java:78)
	at com.codeaffine.archive.ui.internal.viewer.ArchiveContentProvider.getChildren(ArchiveContentProvider.java:38)
	at com.codeaffine.archive.ui.internal.viewer.ArchiveContentProviderWrapper.getChildren(ArchiveContentProviderWrapper.java:27)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:98)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:241)
	at org.eclipse.ui.internal.navigator.extensions.SafeDelegateTreeContentProvider.getChildren(SafeDelegateTreeContentProvider.java:96)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider$1.run(NavigatorContentServiceContentProvider.java:160)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.internalGetChildren(NavigatorContentServiceContentProvider.java:146)
	at org.eclipse.ui.internal.navigator.NavigatorContentServiceContentProvider.getChildren(NavigatorContentServiceContentProvider.java:132)
	at org.eclipse.jface.viewers.AbstractTreeViewer.getRawChildren(AbstractTreeViewer.java:1438)
	at org.eclipse.jface.viewers.TreeViewer.getRawChildren(TreeViewer.java:350)
	at org.eclipse.jface.viewers.StructuredViewer.getFilteredChildren(StructuredViewer.java:850)
	at org.eclipse.jface.viewers.AbstractTreeViewer.getSortedChildren(AbstractTreeViewer.java:638)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:837)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:611)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:790)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1565)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:897)
	at org.eclipse.jface.viewers.AbstractTreeViewer$3.treeExpanded(AbstractTreeViewer.java:1577)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:136)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7585)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5799)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1961)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5367)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4801)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1542)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6484)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4781)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:6016)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5028)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-02-26 22:49:16.609 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-26 22:49:21.041
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 22:49:21.041
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-26 22:49:21.041
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-26 22:49:23.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-02-26 22:49:32.552
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-05 16:51:48.835 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-05 16:51:59.452
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-05 16:51:59.452
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-05 16:51:59.452
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-05 16:52:05.096
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-05 16:52:57.109
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-06 11:14:47.775 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-06 11:14:54.898
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-06 11:14:54.898
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-06 11:14:54.898
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-06 11:14:57.707
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-06 11:15:05.698
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-06 14:40:16.984 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-06 14:40:23.323
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-06 14:40:23.323
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-06 14:40:23.323
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-06 14:40:27.898
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-06 14:40:35.581
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-12 10:45:27.190 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-12 10:45:31.912
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-12 10:45:31.912
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-12 10:45:31.912
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-12 10:45:35.326
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-12 10:45:44.992
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-13 22:04:12.682 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-13 22:04:22.314
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-13 22:04:22.314
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-13 22:04:22.314
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-13 22:04:25.307
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-13 22:05:30.287
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-14 14:11:32.829 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-14 14:11:37.091
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-14 14:11:37.091
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-14 14:11:37.091
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-14 14:11:39.758
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-14 14:11:47.685
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-15 08:59:19.715 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-15 08:59:51.571
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-15 08:59:51.571
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-15 08:59:51.571
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-15 08:59:54.950
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-15 09:00:04.342
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-03-15 13:04:22.156 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-15 13:04:26.318
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-15 13:04:26.318
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-15 13:04:26.318
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-15 13:04:29.143
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-03-15 13:04:37.031
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2023-04-08 21:15:56.712 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2023-04-08 21:15:59.843
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2023-04-08 21:15:59.843
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2023-04-08 21:15:59.844
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-04-08 21:16:01.454
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 21:16:01.454
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 21:16:01.454
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-08 21:16:04.649
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2023-04-08 21:17:33.397
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details
!SESSION 2024-04-25 20:06:25.674 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2024-04-25 20:06:38.129
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-25 20:06:38.129
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-25 20:06:38.129
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-25 20:06:42.067
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\20680'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.ui 1 0 2024-04-25 20:06:51.107
!MESSAGE Setup tasks were performed during startup updating 5 preferences. See 'D:\Software\Tools\Eclipse\eclipse\eclipse-java-2022-09-R-win32-x86_64\eclipse\configuration\org.eclipse.oomph.setup\setup.log' for details

!ENTRY org.eclipse.core.resources 4 1 2024-04-25 20:12:47.483
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:12:47.485
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 4 0 2024-04-25 20:12:47.487
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:12:47.488
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 4 0 2024-04-25 20:12:47.489
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:12:47.489
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.core.resources 4 1 2024-04-25 20:13:03.435
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:13:03.436
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 4 0 2024-04-25 20:13:03.437
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:13:03.437
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 4 0 2024-04-25 20:13:03.438
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java)[274]: java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 274 2024-04-25 20:13:03.438
!MESSAGE Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
!STACK 0
java.lang.Exception: Resource is out of sync with the file system: '/ik-analyzer-master/src/main/java/com/btg/core/util/bbm25/LeafNode2.java'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:778)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3248)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1882)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:332)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
